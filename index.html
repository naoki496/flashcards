<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>古文単語</title>
  <meta name="theme-color" content="#070A10" />
  <link rel="manifest" href="manifest.json">

  <style>
    :root{
      --bg0:#070A10;
      --bg1:#0B1220;
      --panel:rgba(255,255,255,.06);
      --panel2:rgba(255,255,255,.08);
      --line:rgba(255,255,255,.12);
      --line2:rgba(255,255,255,.18);
      --text:#EAF0FF;
      --muted:rgba(234,240,255,.72);

      /* ✅ Violet base */
      --accent:#B56CFF;
      --accent2:#A7D8FF; /* ✅青銀系（フィードバックで使う） */

      --warn:#FFCC66;
      --err:#FF6B7A;
      --ok:#7CFFB2;

      --r:16px;
      --r2:14px;
      --shadow: 0 16px 44px rgba(0,0,0,.55);
      --shadow2: 0 10px 24px rgba(0,0,0,.45);
    }

    *{box-sizing:border-box}
    html,body{height:100%}

    body{
      margin:0;
      color:var(--text);
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
      background:
        radial-gradient(900px 520px at 20% 12%, rgba(181,108,255,.22), transparent 55%),
        radial-gradient(800px 520px at 82% 18%, rgba(167,216,255,.14), transparent 60%),
        radial-gradient(900px 620px at 60% 85%, rgba(181,108,255,.10), transparent 58%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      overflow-x:hidden;
    }

    a{color:rgba(181,108,255,.92)}
    a:hover{color:rgba(181,108,255,1)}

    .wrap{
      max-width:860px;
      margin:0 auto;
      padding:16px;
    }

    h1{
      margin:6px 0 6px;
      font-size:22px;
      letter-spacing:.06em;
      line-height:1.25;
      text-shadow: 0 0 18px rgba(181,108,255,.18);
    }

    .muted{
      color:var(--muted);
      font-size:12px;
      line-height:1.6;
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin:12px 0;
      align-items:center;
    }

    /* ✅ UI整理：主操作／補助 */
    .row.primary button{
      flex:1 1 calc(50% - 10px);
      font-size:16px;
    }
    .row.secondary button{
      flex:1 1 calc(50% - 10px);
      font-size:13px;
      opacity:.80;
    }

    .kpi{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }

    .pill{
      background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.05));
      border:1px solid var(--line);
      border-radius:999px;
      padding:7px 10px;
      font-size:12px;
      color:rgba(234,240,255,.86);
      box-shadow: 0 8px 18px rgba(0,0,0,.18);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .sep{
      height:1px;
      background:linear-gradient(90deg, transparent, rgba(255,255,255,.18), transparent);
      margin:14px 0;
    }

    /* ===== Card (Swipe target) ===== */
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.05));
      border:1px solid rgba(255,255,255,.14);
      border-radius:var(--r);
      padding:18px;
      min-height:180px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      position:relative;
      overflow:hidden;

      /* ✅ スワイプ誤爆を抑える：縦スクロールはブラウザに任せる */
      touch-action: pan-y;
      user-select: none;
      -webkit-user-select: none;
    }

    .card::before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(520px 280px at 18% 10%, rgba(181,108,255,.16), transparent 60%),
        radial-gradient(560px 340px at 88% 20%, rgba(167,216,255,.10), transparent 62%);
      pointer-events:none;
    }

    .card > *{position:relative}

    .big{
      font-size:20px;
      line-height:1.45;
      white-space:pre-wrap;
    }

    #pos{
      color:rgba(234,240,255,.72);
    }

    button{
      appearance:none;
      -webkit-appearance:none;
      background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      color:rgba(234,240,255,.92);
      border:1px solid rgba(255,255,255,.16);
      border-radius:12px;
      padding:12px 14px;
      cursor:pointer;
      box-shadow: var(--shadow2);
      transition: transform .08s ease, border-color .12s ease, background .12s ease, box-shadow .12s ease;
      min-height:44px;
      touch-action:manipulation;
    }

    button:hover{
      background:linear-gradient(180deg, rgba(255,255,255,.13), rgba(255,255,255,.08));
      border-color: rgba(181,108,255,.28);
      box-shadow: 0 14px 28px rgba(0,0,0,.45), 0 0 0 1px rgba(181,108,255,.10);
    }

    button:active{ transform: translateY(1px); }

    button:focus-visible{
      outline:none;
      box-shadow: 0 0 0 3px rgba(181,108,255,.22), var(--shadow2);
    }

    /* 主役ボタン（次へ） */
    #btnNext{
      border-color: rgba(181,108,255,.35);
      box-shadow: 0 14px 28px rgba(0,0,0,.45), 0 0 0 1px rgba(181,108,255,.12);
    }

    input[type="file"]{
      color:rgba(234,240,255,.86);
      font-size:12px;
    }

    details{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.04));
      border:1px solid rgba(255,255,255,.12);
      border-radius:var(--r2);
      padding:10px 12px;
      box-shadow: 0 10px 22px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    summary{
      cursor:pointer;
      color:rgba(234,240,255,.84);
      list-style:none;
    }
    summary::-webkit-details-marker{display:none}
    summary::before{
      content:"▸";
      display:inline-block;
      margin-right:8px;
      transform: translateY(-1px);
      color:rgba(181,108,255,.85);
    }
    details[open] summary::before{content:"▾"}

    .status{font-size:12px;color:var(--ok)}
    .status.warn{color:var(--warn)}
    .status.err{color:var(--err)}

    code{
      background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12);
      padding:2px 8px;
      border-radius:999px;
      color:rgba(234,240,255,.88);
    }

    /* ===== Swipe feedback ===== */
    .card.is-dragging{
      transition:none !important;
      cursor:grabbing;
    }

    /* ✅青銀パルス（スワイプ成功時に軽く気持ち良く） */
    @keyframes pulseBlueSilver {
      0%   { box-shadow: var(--shadow); }
      35%  { box-shadow: 0 18px 50px rgba(0,0,0,.55), 0 0 0 2px rgba(167,216,255,.18), 0 0 36px rgba(167,216,255,.22); }
      100% { box-shadow: var(--shadow); }
    }
    .card.pulse{
      animation: pulseBlueSilver 520ms ease-out;
    }

    @media (max-width:560px){
      .wrap{padding:14px}
      h1{font-size:20px}
      .big{font-size:19px}
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1 style="margin:6px 0 6px;">八東古文単語</h1>
    <div class="muted" style="margin-bottom:6px;">
      生徒向け：<b>初回は自動でデッキを読み込みます</b><br>
      データは端末内に保存されます。オフラインでも動作します（PWA）。
    </div>

    <div class="row">
      <span id="status" class="status">起動中…</span>
    </div>

    <!-- ✅UI整理：主操作 -->
    <div class="row primary">
      <button id="btnNext">次へ（ランダム）</button>
      <button id="btnReveal">答えを見る</button>
    </div>

    <!-- ✅UI整理：補助操作 -->
    <div class="row secondary">
      <button id="btnShuffle">シャッフル（出題履歴リセット）</button>
      <button id="btnCopy">表裏をコピー</button>
    </div>

    <div class="kpi">
      <div class="pill">カード枚数：<span id="kCards">0</span></div>
      <div class="pill">今日見た枚数：<span id="kToday">0</span></div>
      <div class="pill">デッキ：<span id="kSource">-</span></div>
      <div class="pill">最終更新：<span id="kUpdated">-</span></div>
    </div>

    <div class="sep"></div>

    <!-- ✅ここがスワイプ対象 -->
    <div class="card" id="card">
      <div class="muted" id="pos">-</div>
      <div class="big" id="front" style="margin-top:10px;">読み込み中…</div>
      <div class="sep"></div>
      <div class="big" id="back" style="display:none;"></div>
    </div>

    <div class="sep"></div>

    <details>
      <summary>メンテ用；生徒は操作しない</summary>
      <div class="row" style="margin-top:10px;">
        <input id="file" type="file" accept=".csv,text/csv" />
        <button id="btnImport">CSVインポート（任意）</button>
        <button id="btnExport">現在のデッキをCSVで書き出し</button>
        <button id="btnResetDefault">既定デッキに戻す</button>
        <button id="btnResetAll">端末内データ初期化</button>
      </div>
      <div class="muted">
        CSV形式（推奨）：<code>front,back</code>（1行目ヘッダ）。
      </div>
    </details>

    <div class="muted" style="margin-top:12px;">
      ヒント：スマホは「ホーム画面に追加」でアプリ風に使えます。
    </div>
  </div>

<script>
  // --- PWA register（更新を即チェック）
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker
        .register("./sw.js")
        .then((reg) => { reg.update(); })
        .catch(() => {});
    });
  }

  // --- Constants / keys
  const DEFAULT_DECK_URL = "./deck_default.csv";
  const META_URL = "./deck_meta.json";

  const KEY_DECK = "fc_deck_v2";
  const KEY_STATE = "fc_state_v2";
  const KEY_UPDATED = "fc_updated_v2";
  const KEY_SOURCE = "fc_source_v2"; // "default" | "custom"
  const KEY_VERSION = "fc_deck_version_v2"; // meta.version when default

  // ✅軽量SRS（苦手推定）用
  const KEY_STATS = "fc_stats_v1";
  // stats shape:
  // {
  //   revealCount: { [idx]: number },
  //   struggleScore: { [idx]: number },
  //   lastShownAt: number|null,
  //   lastRevealAt: number|null,
  //   lastIndex: number|null,
  //   lastIsRevisit: boolean
  // }

  function loadStats() {
    try {
      return JSON.parse(localStorage.getItem(KEY_STATS)) ?? {
        revealCount: {},
        struggleScore: {},
        lastShownAt: null,
        lastRevealAt: null,
        lastIndex: null,
        lastIsRevisit: false
      };
    } catch {
      return { revealCount:{}, struggleScore:{}, lastShownAt:null, lastRevealAt:null, lastIndex:null, lastIsRevisit:false };
    }
  }
  function saveStats(s) { localStorage.setItem(KEY_STATS, JSON.stringify(s)); }
  function clampScore(x) {
    if (!Number.isFinite(x)) return 0;
    return Math.max(0, Math.min(20, x));
  }

  // --- DOM
  const elCard  = document.getElementById("card");
  const elFront = document.getElementById("front");
  const elBack  = document.getElementById("back");
  const elPos   = document.getElementById("pos");
  const elStatus= document.getElementById("status");

  const kCards  = document.getElementById("kCards");
  const kToday  = document.getElementById("kToday");
  const kUpdated= document.getElementById("kUpdated");
  const kSource = document.getElementById("kSource");

  // --- Minimal CSV parser (quoted fields, commas, CRLF)
  function parseCSV(text) {
    const rows = [];
    let i = 0, field = "", row = [], inQuotes = false;
    while (i < text.length) {
      const c = text[i];
      if (inQuotes) {
        if (c === '"') {
          if (text[i+1] === '"') { field += '"'; i += 2; continue; }
          inQuotes = false; i++; continue;
        }
        field += c; i++; continue;
      } else {
        if (c === '"') { inQuotes = true; i++; continue; }
        if (c === ',') { row.push(field); field = ""; i++; continue; }
        if (c === '\n') { row.push(field); rows.push(row); row = []; field = ""; i++; continue; }
        if (c === '\r') { i++; continue; }
        field += c; i++; continue;
      }
    }
    row.push(field);
    if (row.length > 1 || row[0].trim() !== "") rows.push(row);
    return rows;
  }

  function toCSV(rows) {
    const esc = (s) => {
      s = String(s ?? "");
      const need = /[",\n\r]/.test(s);
      s = s.replace(/"/g, '""');
      return need ? `"${s}"` : s;
    };
    return rows.map(r => r.map(esc).join(",")).join("\n");
  }

  function setStatus(msg, level="ok") {
    elStatus.textContent = msg;
    elStatus.className = "status" + (level==="warn" ? " warn" : level==="err" ? " err" : "");
  }

  function loadDeck() {
    try { return JSON.parse(localStorage.getItem(KEY_DECK)) ?? []; }
    catch { return []; }
  }
  function saveDeck(deck) {
    localStorage.setItem(KEY_DECK, JSON.stringify(deck));
    localStorage.setItem(KEY_UPDATED, new Date().toISOString());
  }
  function loadState() {
    try {
      return JSON.parse(localStorage.getItem(KEY_STATE)) ?? {
        seenToday: 0,
        lastSeenDate: null,
        history: []
      };
    } catch {
      return { seenToday: 0, lastSeenDate: null, history: [] };
    }
  }
  function saveState(st) { localStorage.setItem(KEY_STATE, JSON.stringify(st)); }

  function getSource() { return localStorage.getItem(KEY_SOURCE) || "default"; }
  function setSource(s) { localStorage.setItem(KEY_SOURCE, s); }
  function getVersion() { return localStorage.getItem(KEY_VERSION) || ""; }
  function setVersion(v) { localStorage.setItem(KEY_VERSION, v || ""); }

  function todayKey() {
    const d = new Date();
    return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`;
  }

  let deck = loadDeck();
  let state = loadState();
  let currentIndex = -1;

  // ✅「戻る」のための履歴スタック（表示したカードの並び）
  // 例： [0, 13, 7, 22] で currentIndex=22 の状態
  let navStack = [];
  let isAnimatingNav = false;

  function ensureTodayCounter() {
    const t = todayKey();
    if (state.lastSeenDate !== t) {
      state.lastSeenDate = t;
      state.seenToday = 0;
      saveState(state);
    }
  }

  function updateKPI() {
    ensureTodayCounter();
    kCards.textContent = String(deck.length);
    kToday.textContent = String(state.seenToday);
    const upd = localStorage.getItem(KEY_UPDATED);
    kUpdated.textContent = upd ? new Date(upd).toLocaleString() : "-";
    kSource.textContent = (getSource()==="custom") ? "カスタム" : "既定";
  }

  function showCard(i, opts = {}) {
    // opts:
    // { revisit?:boolean }  …戻る等の「再表示」
    // { silent?:boolean }   …表示はするが演出しない
    if (deck.length === 0) {
      elPos.textContent = "-";
      elFront.textContent = "デッキが空です（既定デッキの読み込みに失敗した可能性があります）";
      elBack.style.display = "none";
      elBack.textContent = "";
      return;
    }

    currentIndex = i;
    const c = deck[i];
    elPos.textContent = `#${i+1} / ${deck.length}`;
    elFront.textContent = c.front ?? "";
    elBack.textContent  = c.back ?? "";
    elBack.style.display = "none";

    // ✅SRS用：カード表示時刻を記録
    const stats = loadStats();
    stats.lastShownAt = Date.now();
    stats.lastRevealAt = null;
    stats.lastIndex = i;
    stats.lastIsRevisit = !!opts.revisit;
    saveStats(stats);

    if (!opts.silent) {
      elCard.classList.remove("pulse");
      // reflow
      void elCard.offsetWidth;
      elCard.classList.add("pulse");
      setTimeout(()=> elCard.classList.remove("pulse"), 700);
    }
  }

  function resetSessionHistory() {
    state.history = [];
    saveState(state);
  }

  // --- 既存の「見た目ランダム」抽選（直近回避）
  function pickRandomAvoidingRecent() {
    if (deck.length === 0) return -1;

    const maxTry = Math.min(80, deck.length * 2);
    let i = -1;
    for (let t = 0; t < maxTry; t++) {
      const cand = Math.floor(Math.random() * deck.length);
      if (cand === currentIndex) continue;
      if (deck.length >= 8 && state.history.includes(cand)) continue;
      i = cand; break;
    }
    if (i === -1) {
      state.history = [];
      i = Math.floor(Math.random() * deck.length);
    }
    return i;
  }

  // ✅苦手寄り（重み付き）抽選
  function pickWeightedByStruggle() {
    if (deck.length === 0) return -1;

    const stats = loadStats();
    const scores = stats.struggleScore || {};

    // 基本1、苦手スコアに応じて最大+6程度まで重くする（露骨すぎない）
    const weights = deck.map((_, i) => {
      const s = Number(scores[String(i)] ?? 0);
      const w = 1 + Math.min(6, Math.max(0, s));
      return w;
    });

    // 直近回避（重み抽選でも露骨連続を避ける）
    const recentSet = new Set(deck.length >= 8 ? state.history : []);
    const usable = weights.map((w, i) => {
      if (i === currentIndex) return 0;
      if (recentSet.has(i)) return 0.2; // 少しだけ残す（詰まり救済）
      return w;
    });

    const total = usable.reduce((a,b)=>a+b,0);
    if (total <= 0) return pickRandomAvoidingRecent();

    let r = Math.random() * total;
    for (let i = 0; i < usable.length; i++) {
      r -= usable[i];
      if (r <= 0) return i;
    }
    return pickRandomAvoidingRecent();
  }

  // ✅「ランダムを装った最適化」：70%通常、30%苦手寄り
  function nextSmart() {
    if (deck.length === 0) return;

    const useStruggle = (Math.random() < 0.30);
    const i = useStruggle ? pickWeightedByStruggle() : pickRandomAvoidingRecent();

    // 履歴更新（既存挙動に準拠）
    state.history.push(i);
    if (state.history.length > Math.min(80, deck.length)) {
      state.history = state.history.slice(-Math.min(80, deck.length));
    }

    ensureTodayCounter();
    state.seenToday += 1;
    saveState(state);

    // ✅ナビ履歴（戻る用）に積む：前進のみ
    if (navStack.length === 0) navStack.push(i);
    else navStack.push(i);

    showCard(i);
    updateKPI();
  }

  // ✅「次へ」直前に、滞在時間で苦手スコアを微調整
  function updateStruggleByDwell() {
    const stats = loadStats();
    if (stats.lastIndex == null || stats.lastIndex < 0) return;

    // ✅「戻る」等の再訪中は学習判定しない（統計の二重汚染を防ぐ）
    if (stats.lastIsRevisit) return;

    const idx = String(stats.lastIndex);
    const scores = stats.struggleScore || {};
    let s = Number(scores[idx] ?? 0);

    // 裏を開いていない場合は学習判定しない（自由運用を尊重）
    if (stats.lastRevealAt == null) {
      scores[idx] = clampScore(s);
      stats.struggleScore = scores;
      saveStats(stats);
      return;
    }

    const dt = Date.now() - stats.lastRevealAt; // 裏→次へ の時間
    // 目安：6秒以上→詰まり、1.5秒未満→軽快
    if (dt >= 6000) s += 1.0;
    else if (dt <= 1500) s -= 0.5;

    scores[idx] = clampScore(s);
    stats.struggleScore = scores;
    saveStats(stats);
  }

  function parseDeckFromCSV(text) {
    const rows = parseCSV(text);
    if (rows.length === 0) return [];

    // detect header
    const header = rows[0].map(s => String(s ?? "").trim().toLowerCase());
    let start = 0, idxFront = 0, idxBack = 1;

    const hFront = header.indexOf("front");
    const hBack  = header.indexOf("back");
    if (hFront >= 0 && hBack >= 0) {
      start = 1; idxFront = hFront; idxBack = hBack;
    }

    const out = [];
    for (let r = start; r < rows.length; r++) {
      const row = rows[r];
      const front = String(row[idxFront] ?? "").trim();
      const back  = String(row[idxBack]  ?? "").trim();
      if (!front && !back) continue;
      out.push({ front, back });
    }
    return out;
  }

  async function fetchJSON(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error("fetch failed");
    return await res.json();
  }

  async function fetchText(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error("fetch failed");
    return await res.text();
  }

  async function ensureDefaultDeckLoaded() {
    // 1) read meta (best-effort)
    let meta = null;
    try { meta = await fetchJSON(META_URL); } catch {}

    const source = getSource();
    const storedVersion = getVersion();
    const metaVersion = meta?.version || "";

    const needsInit = deck.length === 0;
    const canAutoUpdate = (source === "default");
    const needsUpdate = canAutoUpdate && metaVersion && storedVersion && (metaVersion !== storedVersion);

    if (!needsInit && !needsUpdate) {
      if (metaVersion && !storedVersion && source==="default") setVersion(metaVersion);
      return;
    }

    try {
      setStatus(needsInit ? "既定デッキを読み込み中…" : "既定デッキを更新中…", "warn");
      const csv = await fetchText(DEFAULT_DECK_URL);
      const newDeck = parseDeckFromCSV(csv);
      if (newDeck.length === 0) throw new Error("empty deck");

      deck = newDeck;
      saveDeck(deck);
      setSource("default");
      if (metaVersion) setVersion(metaVersion);

      updateKPI();

      // ✅初期表示＋履歴
      showCard(0, { silent:true });
      navStack = [0];

      setStatus(needsUpdate ? "既定デッキを更新しました" : "準備完了（既定デッキ）");
    } catch (e) {
      if (deck.length) {
        setStatus("既定デッキの読み込みに失敗しました（端末内データで継続）", "warn");
      } else {
        setStatus("既定デッキの読み込みに失敗しました（オンライン接続を確認）", "err");
        showCard(-1);
      }
    }
  }

  // ==========================================================
  // 1) スワイプ誤作動対策（角度/閾値/開始禁止エリア）
  // 2) フィードバック（追従＋パルス＋バイブ）
  // 3) 戻る一貫性（履歴スタック＋二重カウント抑止）
  // ==========================================================

  function isInteractiveTarget(t) {
    if (!t) return false;
    // ボタン/入力/詳細/リンク/summary 上はスワイプ無効（タップ優先）
    return !!t.closest("button, a, input, textarea, select, details, summary, label");
  }

  const SWIPE = {
    ANGLE_RATIO: 1.2,      // abs(dx) > abs(dy)*1.2 で横扱い
    DIST_PX: 60,           // 距離閾値
    VEL_PX_PER_MS: 0.35,   // 速度閾値
    MAX_TAP_MS: 450,       // それ以上だと速度判定は弱めに
    OFFSCREEN: () => Math.min(window.innerWidth * 0.9, 520),
  };

  let drag = {
    active:false,
    pointerId:null,
    startX:0, startY:0,
    lastX:0, lastY:0,
    startT:0, lastT:0,
    lockedAxis:null, // "x" | "y" | null
  };

  function setCardTransform(x, withTransition) {
    if (withTransition) {
      elCard.style.transition = "transform 180ms ease, opacity 180ms ease";
    } else {
      elCard.style.transition = "none";
    }
    elCard.style.transform = `translateX(${x}px)`;
  }

  function clearCardTransform() {
    elCard.style.transition = "transform 160ms ease";
    elCard.style.transform = "translateX(0px)";
  }

  function haptic(ms=10){
    try { if (navigator.vibrate) navigator.vibrate(ms); } catch {}
  }

  function animateNavigate(direction /* "next"|"back" */) {
    if (isAnimatingNav) return;
    if (deck.length === 0) return;

    // ✅「戻る」が不可能なら何もしない（最上位）
    if (direction === "back" && navStack.length <= 1) {
      haptic(8);
      elCard.classList.remove("pulse"); void elCard.offsetWidth; elCard.classList.add("pulse");
      setTimeout(()=> elCard.classList.remove("pulse"), 650);
      setStatus("戻れません（これが最初のカードです）", "warn");
      return;
    }

    isAnimatingNav = true;

    const off = SWIPE.OFFSCREEN();
    const outX = (direction === "next") ? -off : off; // next:左へ飛ぶ, back:右へ飛ぶ

    // いったん飛ばす
    elCard.style.transition = "transform 190ms ease, opacity 190ms ease";
    elCard.style.opacity = "0.0";
    elCard.style.transform = `translateX(${outX}px)`;

    // 画面外へ飛んだ後に中身差し替え→反対側から戻す
    setTimeout(() => {
      // ✅中身更新（カウント/苦手推定はルールに従う）
      if (direction === "next") {
        updateStruggleByDwell();
        // nextSmart が showCard/updateKPI/navStack 積みを含む
        // ただし nextSmart は「今のカード」関係なくランダムなので、
        // 既存仕様に合わせてそのまま。
        nextSmart();
      } else {
        // ✅back: navStack を1つ戻すだけ（学習カウントしない）
        navStack.pop();
        const prev = navStack[navStack.length - 1];
        // 再表示扱い（統計二重汚染を防ぐ）
        showCard(prev, { revisit:true, silent:true });
        // KPIは変えない（seenToday増やさない）
        updateKPI();
        setStatus("前のカードへ戻りました");
      }

      // 反対側から入れる
      const inX = (direction === "next") ? off : -off;
      elCard.style.transition = "none";
      elCard.style.opacity = "0.0";
      elCard.style.transform = `translateX(${inX}px)`;

      // reflow
      void elCard.offsetWidth;

      // 戻す
      elCard.style.transition = "transform 190ms ease, opacity 190ms ease";
      elCard.style.opacity = "1.0";
      elCard.style.transform = "translateX(0px)";

      // ✅成功パルス（青銀）
      elCard.classList.remove("pulse"); void elCard.offsetWidth; elCard.classList.add("pulse");
      setTimeout(()=> elCard.classList.remove("pulse"), 700);

      haptic(10);

      setTimeout(() => { isAnimatingNav = false; }, 220);
    }, 210);
  }

  // --- Swipe handlers (pointer events)
  elCard.addEventListener("pointerdown", (e) => {
    if (isAnimatingNav) return;
    if (isInteractiveTarget(e.target)) return;

    drag.active = true;
    drag.pointerId = e.pointerId;
    drag.startX = e.clientX;
    drag.startY = e.clientY;
    drag.lastX = e.clientX;
    drag.lastY = e.clientY;
    drag.startT = performance.now();
    drag.lastT  = drag.startT;
    drag.lockedAxis = null;

    elCard.setPointerCapture?.(e.pointerId);
    elCard.classList.add("is-dragging");
  });

  elCard.addEventListener("pointermove", (e) => {
    if (!drag.active || e.pointerId !== drag.pointerId) return;

    const x = e.clientX, y = e.clientY;
    const dx = x - drag.startX;
    const dy = y - drag.startY;

    // 軸ロック（誤爆防止：角度判定）
    if (!drag.lockedAxis) {
      const adx = Math.abs(dx), ady = Math.abs(dy);
      if (adx < 10 && ady < 10) return; // 微小は無視
      if (adx > ady * SWIPE.ANGLE_RATIO) drag.lockedAxis = "x";
      else if (ady > adx * SWIPE.ANGLE_RATIO) drag.lockedAxis = "y";
      else return;
    }

    // 縦ならブラウザに任せる（カード追従もなし）
    if (drag.lockedAxis === "y") return;

    // 横確定：追従（フィードバック）
    // 少し減衰（気持ち良く）
    const damp = 0.92;
    setCardTransform(dx * damp, false);

    drag.lastX = x; drag.lastY = y;
    drag.lastT = performance.now();
  });

  elCard.addEventListener("pointerup", (e) => {
    if (!drag.active || e.pointerId !== drag.pointerId) return;

    const endT = performance.now();
    const dt = Math.max(1, endT - drag.startT);
    const dx = e.clientX - drag.startX;
    const dy = e.clientY - drag.startY;

    elCard.classList.remove("is-dragging");

    // 途中で縦ロックだった場合は何もしない
    if (drag.lockedAxis !== "x") {
      clearCardTransform();
      drag.active = false;
      return;
    }

    // ✅速度判定
    const vx = dx / dt; // px/ms
    const adx = Math.abs(dx);
    const avx = Math.abs(vx);

    const passDist = adx >= SWIPE.DIST_PX;
    const passVel  = (dt <= SWIPE.MAX_TAP_MS) && (avx >= SWIPE.VEL_PX_PER_MS);

    if (passDist || passVel) {
      // 方向：左スワイプ＝次へ、右スワイプ＝戻る
      if (dx < 0) animateNavigate("next");
      else animateNavigate("back");
    } else {
      // 戻す
      clearCardTransform();
    }

    drag.active = false;
  });

  elCard.addEventListener("pointercancel", (e) => {
    if (!drag.active || e.pointerId !== drag.pointerId) return;
    elCard.classList.remove("is-dragging");
    clearCardTransform();
    drag.active = false;
  });

  // --- Buttons

  // ✅答えを見る：2回目以降の裏表示だけ苦手寄りに（初回は全員見るため）
  document.getElementById("btnReveal").onclick = () => {
    if (deck.length === 0) return;

    const willShow = (elBack.style.display === "none");
    elBack.style.display = willShow ? "block" : "none";

    if (willShow) {
      const stats = loadStats();
      stats.lastRevealAt = Date.now();
      stats.lastIndex = currentIndex;

      const idx = String(currentIndex);
      const rc = stats.revealCount || {};
      const scores = stats.struggleScore || {};

      const newCount = (Number(rc[idx] ?? 0) + 1);
      rc[idx] = newCount;

      // ✅2回目以降に裏を開く＝理解が固まっていない可能性が高い
      if (newCount >= 2) {
        const s = Number(scores[idx] ?? 0);
        scores[idx] = clampScore(s + 1.0);
      }

      stats.revealCount = rc;
      stats.struggleScore = scores;
      saveStats(stats);
    }
  };

  // ✅次へ：滞在時間で微調整→smart抽選
  document.getElementById("btnNext").onclick = () => {
    updateStruggleByDwell();
    nextSmart();
  };

  document.getElementById("btnShuffle").onclick = () => {
    resetSessionHistory();
    nextSmart();
  };

  document.getElementById("btnCopy").onclick = async () => {
    if (deck.length === 0) return;
    const c = deck[currentIndex >= 0 ? currentIndex : 0];
    const txt = `【表】${c.front ?? ""}\n【裏】${c.back ?? ""}`;
    try {
      await navigator.clipboard.writeText(txt);
      setStatus("コピーしました");
    } catch {
      setStatus("コピーできませんでした（ブラウザ権限）", "warn");
    }
  };

  document.getElementById("btnImport").onclick = async () => {
    const f = document.getElementById("file").files?.[0];
    if (!f) { alert("CSVファイルを選択してください"); return; }
    const text = await f.text();
    const newDeck = parseDeckFromCSV(text);
    if (newDeck.length === 0) { alert("カードが0件でした"); return; }

    deck = newDeck;
    saveDeck(deck);
    setSource("custom");
    setVersion("");
    state.history = [];
    saveState(state);

    updateKPI();
    showCard(0, { silent:true });
    navStack = [0];

    setStatus(`インポート完了：${deck.length}枚（カスタム）`);
  };

  document.getElementById("btnExport").onclick = () => {
    if (deck.length === 0) { alert("デッキが空です"); return; }
    const rows = [["front","back"], ...deck.map(c => [c.front ?? "", c.back ?? ""])];
    const csv = toCSV(rows);
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "deck.csv";
    a.click();
    URL.revokeObjectURL(url);
  };

  document.getElementById("btnResetDefault").onclick = async () => {
    if (!confirm("既定デッキに戻します。よろしいですか？")) return;
    setSource("default");
    setVersion("");
    deck = [];
    saveDeck(deck);
    state.history = [];
    saveState(state);
    updateKPI();
    await ensureDefaultDeckLoaded();
  };

  document.getElementById("btnResetAll").onclick = () => {
    if (!confirm("端末内のデッキと学習データを初期化します。よろしいですか？")) return;
    localStorage.removeItem(KEY_DECK);
    localStorage.removeItem(KEY_STATE);
    localStorage.removeItem(KEY_UPDATED);
    localStorage.removeItem(KEY_SOURCE);
    localStorage.removeItem(KEY_VERSION);
    localStorage.removeItem(KEY_STATS);
    deck = [];
    state = loadState();
    currentIndex = -1;
    navStack = [];
    updateKPI();
    showCard(-1);
    setStatus("初期化しました", "warn");
  };

  // --- Init
  (async () => {
    updateKPI();

    if (deck.length) {
      showCard(0, { silent:true });
      navStack = [0];
      setStatus("準備完了（端末内データ）");
    } else {
      showCard(-1);
    }

    await ensureDefaultDeckLoaded();
    updateKPI();

    // deckがあるのにcurrentIndex未設定だった場合
    if (deck.length && (currentIndex == null || currentIndex < 0)) {
      showCard(0, { silent:true });
      navStack = [0];
    }

    if (deck.length && currentIndex === 0) {
      setStatus(getSource()==="custom" ? "準備完了（カスタム）" : "準備完了（既定デッキ）");
    }
  })();
</script>
</body>
</html>
